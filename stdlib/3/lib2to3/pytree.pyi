# Stubs for lib2to3.pytree (Python 3.6)

from typing import Any, Dict, Iterator, List, Optional, Tuple, TypeVar, Union

from .pgen2.grammar import Grammar

_P = TypeVar('_P')
_NL = Union[Node, Leaf]
_Context = Tuple[str, int, int]
_Results = Dict[str, _NL]

HUGE: int

def type_repr(type_num: int) -> str: ...

class Base:
    type: int
    parent: Optional[Node]
    children: List[_NL]
    was_changed: bool
    was_checked: bool
    def __eq__(self, other: Any) -> bool: ...
    __hash__: None  # type: ignore
    def _eq(self: _P, other: _P) -> bool: ...
    def clone(self: _P) -> _P: ...
    def post_order(self) -> Iterator[_NL]: ...
    def pre_order(self) -> Iterator[_NL]: ...
    def replace(self, new: _NL) -> None: ...
    def get_lineno(self) -> int: ...
    def changed(self) -> None: ...
    def remove(self) -> Optional[int]: ...
    @property
    def next_sibling(self) -> Optional[_NL]: ...
    @property
    def prev_sibling(self) -> Optional[_NL]: ...
    def leaves(self) -> Iterator[Leaf]: ...
    def depth(self) -> int: ...
    def get_suffix(self) -> str: ...

class Node(Base):
    prefix: str
    fixers_applied: List[Any]
    def __init__(self, type: int, children: List[_NL], context: Optional[Any] = ..., prefix: Optional[Any] = ..., fixers_applied: Optional[List[Any]] = ...) -> None: ...
    def set_child(self, i: int, child: _NL) -> None: ...
    def insert_child(self, i: int, child: _NL) -> None: ...
    def append_child(self, child: _NL) -> None: ...

class Leaf(Base):
    lineno: int
    column: int
    prefix: str
    value: str
    fixers_applied: List[Any]
    def __init__(self, type: int, value: str, context: Optional[_Context] = ..., prefix: Optional[str] = ..., fixers_applied: List[Any] = ...) -> None: ...

def convert(gr: Grammar, raw_node: Tuple[int, str, _Context, List[_NL]]) -> _NL: ...

class BasePattern:
    type: int
    content: Optional[str]
    name: Optional[str]
    def optimize(self: _P) -> _P: ...
    def match(self, node: _NL, results: Optional[_Results] = ...) -> bool: ...
    def match_seq(self, nodes: List[_NL], results: Optional[_Results] = ...) -> bool: ...
    def generate_matches(self, nodes: List[_NL]) -> Iterator[Tuple[int, _Results]]: ...

class LeafPattern(BasePattern):
    def __init__(self, type: Optional[Any] = ..., content: Optional[Any] = ..., name: Optional[Any] = ...) -> None: ...

class NodePattern(BasePattern):
    wildcards: bool
    def __init__(self, type: Optional[int] = ..., content: Optional[str] = ..., name: Optional[str] = ...) -> None: ...

class WildcardPattern(BasePattern):
    min: int
    max: int
    def __init__(self, content: Optional[str] = ..., min: int = ..., max: int = ..., name: Optional[str] = ...) -> None: ...
    def optimize(self) -> WildcardPattern: ...

class NegatedPattern(BasePattern):
    def __init__(self, content: Optional[str] = ...) -> None: ...

def generate_matches(patterns: List[BasePattern], nodes: List[_NL]) -> Iterator[Tuple[int, _Results]]: ...
